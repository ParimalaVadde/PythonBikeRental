transformed_df
analysis_task_id	sds_upload_name	analysis_external_reference_id	client_name	upload_user	sds_upload_ts	sds_note	unique_payment_row	request_id	user_request_id	request_time	file_uploaded_ts	analysis_stage	period_start_date	period_end_date	client_ecid	request_name	analysis_conducted_dt	note	shared_with_users	source	request_user	vendor_name	business_entity_name	client_vendor_id	client_vendor_site_id	country	vendor_hq_country	state_province	postal_code	street_line_1	street_line_2	city	primary_phone_number	personal	email	website	vendor_contact_name	tax_id	dba	vendor_ultimate_parent_name	annual_spend	sum_of_payments	count_of_payments	count_of_invoices	reported_annual_revenue	payment_ccy	payment_mode	payment_terms	payment_term_days	payment_terms_discount_ind	payment_terms_discount_rate	payment_terms_discount_days	actual_days_payment_outstanding	vendor_cat_clientdef_1	vendor_cat_clientdef_2	vendor_cat_clientdef_3	vendor_cat_clientdef_4	vendor_cat_userdef_1	vendor_cat_userdef_2	vendor_cat_userdef_3	vendor_cat_userdef_4	sds_supplier_id	validation_type	match_strength_name	match_strength_address	match_strength_country	match_strength_state	match_strength_postcode	average_vendor_dso	average_vendor_dpo	average_vendor_dio	level-1	level-2	level-3	scf_industry_sector_dso_25	scf_industry_sector_dso_50	scf_industry_sector_dso_75	scf_industry_group_dso_25	scf_industry_group_dso_50	scf_industry_group_dso_75	filter_analyzable	filter_adjustable	filter_monetizable	filter_country	filter_employee	trust	govt	real_estate	utilities	insurance	fi	filter_interco	filter_individual	do_not_campaign	payment_preference	moody	vendor_credit_rating_moody_date	sp	vendor_credit_rating_sp_date	vendor_credit_rating_recent	credit_revolver_rate	cost_of_goods_sold	ind_jpmc	supplier_ecid	enrolled_scf_supplier	scf_buyerlist	scf_throughput_usd	scf_avg_spread	scf_avg_payment_terms	scf_rate_proposed	scf_rate_offered	scf_esg_discount	scf_ind_decline	vendor_card_tier	enrolled_vc_supplier	vc_concierge	virtual_card_vcn	spend_on_jpmc_vc	vc_enrollment_duration_years	vcn_payment_accepted	vc_buyercount	vc_interchange_amt	cms_enrolled	businessbank_enrolled	stp_partnerships	vc_campaigned_previously	vc_acceptance_tier_legacy	vc_acceptance_tier_model	vc_acceptance_tier_userdefined	vc_campaign_count	vc_campaign_accepts	jpmc_cc_payment_accepted	jpmc_cc_spend	jpmc_cc_enrolled_years	jpmc_cc_buyer_count	match_confidence	matched_level_2	matched_level_3_summary	matched_level_3_lineitem	matched_fleet_ind	matched_data_quality	matched_mcc	google_places_id	enigma_id	Enigma_business_id	year_incorporated	registered_agents	associated_people	industries	company_structure	associated_tax_ids	technologies	has_online_payments	card_revenue	card_transactions_stability	supplier_segmentation	rebate_rate	stg_business_entity_id	stg_payor_business_entity_id	ind_virtualcard_campaign_count	google_flag	ind_card_match	stg_codelist	product_segmentation_applicable	google_place_id	cms_subacct_enrolled	stg_jpmc_business_entity_id
d8c5ff84-1ca5-4dfd-9266-f89ff4a07c26	SAILDRONE INC 2025-08 15244  CB v2 20250811 19:48:37	d8c5ff84-1ca5-4dfd-9266-f89ff4a07c27	SAILDRONE INC	u856923	2024-07-19T12:00:00.000Z		CITY OF ALAMEDA168ACH	d8c5ff84-1ca5-4dfd-9266-f89ff4a07c25	SAILDRONE INC 2025-08 15244  CB v2 20250811 19:48:37	1.75494E+12		ANALYSIS_FINAL	2024-07-19T12:00:00.000Z	2025-07-14T12:00:00.000Z	538669316	SAILDRONE INC 2025-08 15244  CB v2	20250811	SAILDRONE INC 2025-08 15244  CB v2   DAP file, unknown as pay type with same supplier updated to lik	N792158, E056214	Commercial Card	E057348	CITY OF ALAMEDA	CITY ALAMEDA	168		US	US	CA	94501	4745 MANGELS BLVD		Alameda					City of Alameda (Fe				1322572.09	1322572.09	22				ACH																									Government	Municipal	Municipal-City										Y	N	N	Y	N	N	N	N	N	N										N		N																		N	N		Y				1	0					Medium	Yes	Yes	Yes			7523														Government	0.005	8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	bb47d9f7-c631-a592-a734-8221082535bf								2d35a04a-5fdf-50d5-7750-c1c7621ddc33
d8c5ff84-1ca5-4dfd-9266-f89ff4a07c26	SAILDRONE INC 2025-08 15244  CB v2 20250811 19:48:37	d8c5ff84-1ca5-4dfd-9266-f89ff4a07c27	SAILDRONE INC	u856923	2024-07-19T12:00:00.000Z		CITY OF ALAMEDA2080Check	d8c5ff84-1ca5-4dfd-9266-f89ff4a07c25	SAILDRONE INC 2025-08 15244  CB v2 20250811 19:48:37	1.75494E+12		ANALYSIS_FINAL	2024-07-19T12:00:00.000Z	2025-07-14T12:00:00.000Z	538669316	SAILDRONE INC 2025-08 15244  CB v2	20250811	SAILDRONE INC 2025-08 15244  CB v2   DAP file, unknown as pay type with same supplier updated to lik	N792158, E056214	Commercial Card	E057348	CITY OF ALAMEDA	CITY ALAMEDA	2080		US	US	CA	94501	950 W MALL SQ		ALAMEDA			SFox@riverrockreg.c	https://www.alamedaca.gov/Departments/Public-Works-Department	City of Alameda (Re		ALAMEDA CITY OF		26229.08	26229.08	5				Check																									Government	Municipal	Municipal-City										Y	N	N	Y	N	N	N	N	N	N										N		N																		N	N		Y				1	0					Medium	Yes	Yes	Yes			7523		E0024f192000021dc		2017	['JOHN S TOUNGER']	[{'name': 'AARON CLEMENTS', 'titles': ['CHIEF FINANCIAL OFFICER']}, {'name': 'LUCY FARBER', 'titles'	{'classification_description': 'city government office', 'classification_type': 'enigma_description'		320536529			{'end_date': '2025-05-31', 'date_accessible': '2025-08-15', '1m': {'start_date': '2025-05-01', 'aver	{'end_date': '2025-05-31', 'date_accessible': '2025-08-15', '1m': {'start_date': '2025-05-01', 'days	Government	0.005	8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	bb47d9f7-c631-a592-a734-8221082535bf								2d35a04a-5fdf-50d5-7750-c1c7621ddc33


preferred_contacts

stg_business_entity_id	contact_name	contact_title	is_active	business_entity_contact_id
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	City of Alameda (Fe		TRUE	dcb1398e-5825-dc60-8bd4-bc9ef14349e5
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	City of Alameda (Re		TRUE	2379dc1d-0d17-ffc2-3f6a-1cd5e4aecdf7


transformed_relationship

stg_business_entity_id	business_entity_contact_id	stg_related_business_entity_id	related_business_entity_contact_id	business_entity_role	related_business_entity_role	client_vendor_id	client_vendor_site_id	client_ecid	supplier_ecid	is_active	business_entity_relationship_id
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	dcb1398e-5825-dc60-8bd4-bc9ef14349e5	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	2080		538669316		TRUE	59e6e6e5-f7ac-0a5e-3be0-d5f8c935c282
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	2379dc1d-0d17-ffc2-3f6a-1cd5e4aecdf7	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	2080		538669316		TRUE	5e1c7fb6-4feb-0f85-991f-b6ae7fdcae41
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	dcb1398e-5825-dc60-8bd4-bc9ef14349e5	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	168		538669316		TRUE	59e6e6e5-f7ac-0a5e-3be0-d5f8c935c282
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	2379dc1d-0d17-ffc2-3f6a-1cd5e4aecdf7	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	168		538669316		TRUE	5e1c7fb6-4feb-0f85-991f-b6ae7fdcae41



but expected output in transformed_relationship is based on business_entity_contact_id,contact_name , if we map them with transformed_df

stg_business_entity_id	business_entity_contact_id	stg_related_business_entity_id	related_business_entity_contact_id	business_entity_role	related_business_entity_role	client_vendor_id	client_vendor_site_id	client_ecid	supplier_ecid	is_active	business_entity_relationship_id
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	2379dc1d-0d17-ffc2-3f6a-1cd5e4aecdf7	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	2080		538669316		TRUE	5e1c7fb6-4feb-0f85-991f-b6ae7fdcae41
8473f193-8721-4fe0-87d8-ec4a3c3bbdd0	dcb1398e-5825-dc60-8bd4-bc9ef14349e5	bb47d9f7-c631-a592-a734-8221082535bf		supplier	buyer	168		538669316		TRUE	59e6e6e5-f7ac-0a5e-3be0-d5f8c935c282

existing code

def relationship(transformed_business_entity, transformed_contacts, transformed_df):
    from pyspark.sql import DataFrame
    from pyspark.sql.functions import col, lit, when, coalesce, isnan
    from pyspark.sql.types import StringType
    
    # # Get vendor contact names from transformed_df
    # vendor_names_df = transformed_df.select(
    #     col("stg_business_entity_id"),
    #     col("vendor_contact_name").alias("contact_name")
    # ).distinct()

    # # Joining this with transformed_contacts to get the accurate business_entity_contact_id
    # preferred_contacts = vendor_names_df.join(
    #     transformed_contacts.select("stg_business_entity_id", "contact_name", "business_entity_contact_id"),
    #     on=["stg_business_entity_id", "contact_name"],
    #     how="inner"
    # ).distinct()
    
    # Only keep contacts that actually have contact names
    # transformed_contacts = transformed_contacts.filter(col("contact_name").isNotNull())

    # # Generate UUIDs only for valid contacts
    # if transformed_contacts.count() > 0:
    #     transformed_contacts = transformed_contacts.withColumn(
    #         "business_entity_contact_id",
    #         compute_uuid_udf(struct(*transformed_contacts.columns))
    #     )
        
    preferred_contacts = transformed_contacts.select("stg_business_entity_id", "contact_name", "business_entity_contact_id")
    
    # Print column names for debugging
    print("transformed_business_entity columns:", transformed_business_entity.columns)
    print("transformed_df columns:", transformed_df.columns)

    # Create a mapping from client_name to stg_business_entity_id using business_entity_details
    client_mapping = transformed_business_entity.select(
        col("business_entity_name").alias("client_name"),
        col("stg_business_entity_id").alias("client_stg_business_entity_id")
    )
    

    # Initialize list to collect all relationship DataFrames
    relationship_dfs = []
    
    # 1. Create client -> firm relationships first (for distinct clients)
    # Filter out empty/null stg_business_entity_id and join with transformed_df to get required columns
    distinct_clients = transformed_df.select(
        "client_name", 
        "stg_business_entity_id",
        "client_vendor_id",
        "client_vendor_site_id", 
        "client_ecid",
        "supplier_ecid"
    ).filter(
        col("client_name").isNotNull() & 
        (col("client_name") != "") &
        col("stg_business_entity_id").isNotNull() & 
        (col("stg_business_entity_id") != "") &
        (col("stg_business_entity_id") != "null") &
        (col("stg_business_entity_id") != "none")
    ).distinct()
    
    client_firm_df = distinct_clients.join(
        client_mapping,
        on="client_name",
        how="inner"
    ).select(
        col("client_stg_business_entity_id").alias("stg_business_entity_id"),
        lit(None).alias("business_entity_contact_id"),
        lit("2d35a04a-5fdf-50d5-7750-c1c7621ddc33").alias("stg_related_business_entity_id"),
        lit(None).alias("related_business_entity_contact_id"),
        lit("client").alias("business_entity_role"),
        lit("firm").alias("related_business_entity_role"),
        lit(None).alias("client_vendor_id"),
        lit(None).alias("client_vendor_site_id"),
        lit(None).alias("client_ecid"),
        lit(None).alias("supplier_ecid")
    )
    
    relationship_dfs.append(client_firm_df)
    
    # 2. Create supplier -> client relationships
    # Filter out empty/null stg_business_entity_id
    supplier_client_base = transformed_df.filter(
        col("stg_business_entity_id").isNotNull() & 
        (col("stg_business_entity_id") != "") &
        (col("stg_business_entity_id") != "null") &
        (col("stg_business_entity_id") != "none")
    ).join(
        client_mapping,
        on="client_name",
        how="inner"
    ).join(
        preferred_contacts,
        on="stg_business_entity_id",
        how="left"
    )
    
    supplier_client_df = supplier_client_base.select(
        col("stg_business_entity_id"),
        col("business_entity_contact_id"),
        col("client_stg_business_entity_id").alias("stg_related_business_entity_id"),
        lit(None).alias("related_business_entity_contact_id"),
        lit("supplier").alias("business_entity_role"),
        lit("buyer").alias("related_business_entity_role"),
        col("client_vendor_id"),
        col("client_vendor_site_id"),
        col("client_ecid"),
        col("supplier_ecid")
    )
    
    relationship_dfs.append(supplier_client_df)
    
    # 3. Create supplier -> firm relationships (only when supplier_ecid is not null/empty)
    supplier_firm_base = transformed_df.filter(
        col("supplier_ecid").isNotNull() & 
        (col("supplier_ecid") != "") & 
        (col("supplier_ecid") != "NULL") &
        col("stg_business_entity_id").isNotNull() & 
        (col("stg_business_entity_id") != "") &
        (col("stg_business_entity_id") != "null") &
        (col("stg_business_entity_id") != "none")
    ).join(
        preferred_contacts,
        on="stg_business_entity_id",
        how="left"
    )
    
    supplier_firm_df = supplier_firm_base.select(
        col("stg_business_entity_id"),
        col("business_entity_contact_id"),
        lit("2d35a04a-5fdf-50d5-7750-c1c7621ddc33").alias("stg_related_business_entity_id"),
        lit(None).alias("related_business_entity_contact_id"),
        lit("client").alias("business_entity_role"),
        lit("firm").alias("related_business_entity_role"),
        col("client_vendor_id"),
        col("client_vendor_site_id"),
        col("client_ecid"),
        col("supplier_ecid")
    )

    relationship_dfs.append(supplier_firm_df)
    
    # Union all relationship DataFrames
    union_df = relationship_dfs[0]
    for df in relationship_dfs[1:]:
        union_df = union_df.union(df)
    
    # Drop duplicates
    union_df = union_df.dropDuplicates()


    return union_df
	
# Call the `relationship` function and assign the result to `transformed_relationship`
transformed_relationship = relationship(transformed_business_entity_details, transformed_contacts, transformed_df)

transformed_relationship = transformed_relationship.withColumn(
    "is_active", 
    lit(True)  # This creates a Boolean column with True values for all rows
)


# Remove the line that renames "related_business_entity_id" since it doesn't exist in our schema
# transformed_relationship = transformed_relationship.withColumnRenamed("related_business_entity_id", "stg_related_business_entity_id")

# Check for void data types before proceeding
print("Data types in transformed_relationship:")
for col_name, col_type in transformed_relationship.dtypes:
    print(f"{col_name}: {col_type}")

# Find columns with void data type
void_columns = [col_name for col_name, col_type in transformed_relationship.dtypes if col_type == 'void']
print(f"Void columns found: {void_columns}")

if void_columns:
    print(f"Fixing void columns: {void_columns}")
    for void_col in void_columns:
        transformed_relationship = transformed_relationship.withColumn(
            void_col, 
            lit(None).cast(StringType())  # Cast void to nullable string
        )

# Generate UUID for business_entity_relationship_id
transformed_relationship_columns = [
    col for col in transformed_relationship.columns 
    if col not in ['client_ecid', 'client_vendor_id', 'client_vendor_site_id', 'supplier_ecid']
]

transformed_relationship = transformed_relationship.withColumn(
    "business_entity_relationship_id",
    compute_uuid_udf(struct(*[col(c) for c in transformed_relationship_columns]))
)

write_single_csv_to_s3_fixed(
    transformed_relationship,
    s3_bucket="app-id-111597-dep-id-114116-uu-id-9x0jt94siuto",
    s3_key="pfd_scripts/pfd_staging_pvr_test/transformed_relationship.csv",
    temp_path="s3://app-id-111597-dep-id-114116-uu-id-9x0jt94siuto/upsert/pfd_staging/_tmp"
)


*****************************************

from pyspark.sql.functions import col

# Supplier -> client relationships
supplier_client_base = transformed_df.filter(
    col("stg_business_entity_id").isNotNull() & 
    (col("stg_business_entity_id") != "") & 
    (col("stg_business_entity_id") != "null") & 
    (col("stg_business_entity_id") != "none")
).join(
    client_mapping,
    on="client_name",
    how="inner"
).join(
    preferred_contacts,
    (transformed_df["stg_business_entity_id"] == preferred_contacts["stg_business_entity_id"]) &
    (transformed_df["vendor_contact_name"] == preferred_contacts["contact_name"]),
    how="left"
)


**************************************

Error Category: QUERY_ERROR; Failed Line Number: 659; AnalysisException: Reference 'stg_business_entity_id' is ambiguous, could be: stg_business_entity_id, stg_business_entity_id.



**********************************************


# Alias the dataframes before join
df = transformed_df.alias("df")
pc = preferred_contacts.alias("pc")

supplier_client_base = df.filter(
    col("df.stg_business_entity_id").isNotNull() & 
    (col("df.stg_business_entity_id") != "") & 
    (col("df.stg_business_entity_id") != "null") & 
    (col("df.stg_business_entity_id") != "none")
).join(
    client_mapping.alias("cm"),
    df["client_name"] == col("cm.client_name"),
    how="inner"
).join(
    pc,
    (df["stg_business_entity_id"] == pc["stg_business_entity_id"]) &
    (df["vendor_contact_name"] == pc["contact_name"]),
    how="left"
)

supplier_client_df = supplier_client_base.select(
    df["stg_business_entity_id"],
    pc["business_entity_contact_id"],
    col("cm.client_stg_business_entity_id").alias("stg_related_business_entity_id"),
    lit(None).alias("related_business_entity_contact_id"),
    lit("supplier").alias("business_entity_role"),
    lit("buyer").alias("related_business_entity_role"),
    df["client_vendor_id"],
    df["client_vendor_site_id"],
    df["client_ecid"],
    df["supplier_ecid"]
)


**********************************************************************************************************************



seems like this function is not working as expected technology_used column is null. or '' still it is consider df.count > 0 and trying to join

def combine_flattened_results(base_df, flattened_dfs, join_key=ss.base_col):
    """
    Combine all flattened DataFrames back to base DataFrame using LEFT JOIN 
    but filter out rows with no actual data.
    """
    result_df = base_df.select(join_key).distinct()
    
    for df_name, df in flattened_dfs.items():
        if df.count() > 0:
            print(f"Joining {df_name}...")
            result_df = result_df.join(df, on=join_key, how="left")
        else:
            print(f"Skipping {df_name} - no data to join")
    
    # Identify non-key columns
    non_key_cols = [c for c in result_df.columns if c != join_key]
    
    # Filter out rows where all other columns are NULL or empty
    condition = None
    for c in non_key_cols:
        col_cond = (
            col(c).isNotNull() &
            (col(c) != "") &
            (col(c) != "[]") &
            (col(c) != "{}")
        )
        condition = col_cond if condition is None else (condition | col_cond)
    
    if condition is not None:
        result_df = result_df.filter(condition)

    result_df = result_df.dropDuplicates()
    
    return result_df
