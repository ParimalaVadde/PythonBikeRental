
registered_agents values are not getting correctly flattened, only 2 values i can see after flattening i.elementCASSIE WHITLOCK;INCORP SERVICES INC;JESSICA BJORLING;TODD GRIERSON
C T CORPORATION SYSTEM;CT CORPORATION SYSTEM;THE CORPORATION TRUST INCORPORATED

no other values in transformed_json_df for registered_agents apart from above 2
 

values in registered_agents column 
registered_agents
['KIRA GABER', 'NATIONAL REGISTERED AGENTS INC', 'BRIAN MUNDEN', 'LEWIS PR INC', 'SECRETARY OF STATE']
['UNITED STATES CORPORATION AGENTS INC']
['C T CORPORATION SYSTEM', '825 8TH AVENUE']
[]
['CASSIE WHITLOCK', 'INCORP SERVICES INC', 'JESSICA BJORLING', 'TODD GRIERSON']
['GRYFON ENTERPRISES CORP']
['C T CORPORATION SYSTEM', 'CT CORPORATION SYSTEM', 'THE CORPORATION TRUST INCORPORATED']
['GRYFON ENTERPRISES CORP']
[]
['JOEL DAVID CHESTERMAN']
['CYRUS DEYHIMI', 'INCORP SERVICES INC', 'MICHAEL GRAY', 'NO AGENT', 'PARADIGM SAMPLE LLC', 'REGISTERED AGENT SOLUTIONS INC', 'REGISTERED AGENTS INC', 'ROBERT GRAY', 'SIMA VASA', 'TEXAN REGISTERED AGENT LLC']
['C T CORPORATION SYSTEM', 'ARIBA INC', 'CT CORPORATION SYSTEM', 'THE CORPORATION TRUST INCORPORATED']
['C T CORPORATION SYSTEM', 'CT CORPORATION SYSTEM', 'THE CORPORATION TRUST INCORPORATED']
[]
[]
[]
['HOWELL LEGAL INC']
[]
[]
['RODRIGUEZ-MCCLOSKEY PLLC']
['RODRIGUEZ-MCCLOSKEY PLLC']
['REBECCA MARIE BODONY']
['C T CORPORATION SYSTEM', 'CT CORPORATION SYSTEM', 'THE CORPORATION TRUST INCORPORATED']
['C T CORPORATION SYSTEM', 'CT CORPORATION SYSTEM', 'AGENT REVOKED', 'JULISSA BETANCOURT', 'KY SECRETARY OF STATE', 'ND SECRETARY OF STATE N D C C 10-01 1-13', 'SALESFORCE COM INC', 'SALESFORCE ORG', 'SECRETARY OF STATE', 'SERVE SECRETARY OF STATE FOR MAILING TO', 'THE CORPORATION TRUST INCORPORATED']




jsoncol = ["stg_business_entity_id", "registered_agents", "associated_people", "industries", "technologies", "card_revenue", "card_transactions_stability", "associated_tax_ids"]

def flatten_nested_json_column(df, column_name, schema, explode_array=True):
    """
    Flattens a nested JSON column in a PySpark DataFrame.
    
    Args:
        df (DataFrame): The input PySpark DataFrame.
        column_name (str): The name of the JSON column to flatten.
        schema (StructType): The schema of the JSON column.
        explode_array (bool): Whether to explode arrays or join with semicolon.
    
    Returns:
        DataFrame: The DataFrame with the flattened JSON column.
    """
    try:
        # NEW: Check if the column exists and has any non-null values
        if column_name not in df.columns:
            print(f"Column {column_name} does not exist in DataFrame")
            return df
            
        # NEW: Check if all values in the column are null
        non_null_count = df.filter(col(column_name).isNotNull()).count()
        
        if non_null_count == 0:
            print(f"Column {column_name} contains only null values, skipping flattening")
            # Just return the dataframe as-is, keeping the null column
            return df
        
        # Parse the JSON column into structured data
        df = df.withColumn(column_name, from_json(col(column_name), schema))
        
        # If explode_array is False, join array elements with semicolon
        if not explode_array:
            df = df.withColumn(column_name, concat_ws(";", col(column_name)))
            return df
        
        # Explode the array to create one row per element
        df = df.withColumn(column_name, explode(col(column_name)))
        # Iterate over the fields in the schema
        for field in schema.elementType.fields:  # Use `elementType` for ArrayType
            field_name = field.name
            field_type = field.dataType
            # If the field is a nested struct, recursively flatten it
            if isinstance(field_type, StructType):
                for nested_field in field_type.fields:
                    nested_field_name = nested_field.name
                    df = df.withColumn(
                        f"{column_name}__{field_name}__{nested_field_name}",
                        col(f"{column_name}.{field_name}.{nested_field_name}")
                    )
            else:
                # If the field is not nested, extract it directly
                df = df.withColumn(f"{column_name}__{field_name}", col(f"{column_name}.{field_name}"))
        # Drop the original JSON column
        df = df.drop(column_name)
    except Exception as error:
        print(f"Error flattening column {column_name}: {error}")
    return df

registered_agents_schema = ArrayType(StringType())

# NEW: Process registered_agents with null handling
    if "registered_agents" in transformed_json_df.columns:
        transformed_json_df = utl.flatten_nested_json_column(
            transformed_json_df,
            "registered_agents",
            ss.registered_agents_schema,
            explode_array=False
        )
    else:
        print("Warning: registered_agents column not found")
		
		
		
		
transformed_characteristics = transformed_df.select(*ss.characteristics)
    
    
    transformed_characteristics = transformed_characteristics.join(
    transformed_json_df.select("stg_business_entity_id", "registered_agents"),
    on="stg_business_entity_id",
    how="left"
    )

    # Perform a left join between `transformed_characteristics` and `transformed_json_df`
    transformed_melt_characteristics = utl.melt_dataframe(
    transformed_characteristics,
    id_column="stg_business_entity_id",
    columns_to_melt=ss.characteristics_columns,
    melted_column_names=("characteristic_type", "characteristic_value"))

    # Get the current date
    current_date = datetime.today().strftime("%Y-%m-%d")

    # Update the `characteristic_value` column based on the condition
    transformed_melt_characteristics = transformed_melt_characteristics.withColumn(
		"characteristic_value",
		F.when(
			F.col("characteristic_type").isin("moody", "sp"),
			F.concat_ws(";", F.col("characteristic_type"), F.col("characteristic_value"), F.lit(current_date))
		).otherwise(F.col("characteristic_value"))
	)

    # Update the `characteristic_type` column based on the condition
    transformed_melt_characteristics = transformed_melt_characteristics.withColumn(
		"characteristic_type",
		F.when(
			F.col("characteristic_type").isin("moody", "sp"),
			F.lit("credit_rating_provider_date")
		).otherwise(F.col("characteristic_type"))
	)
    transformed_melt_characteristics = transformed_melt_characteristics.filter(
		col("characteristic_value").isNotNull()
	)

    transformed_melt_characteristics = transformed_melt_characteristics.withColumn(
    "is_active", 
    lit(True)  # This creates a Boolean column with True values for all rows
    )

    transformed_melt_characteristics = transformed_melt_characteristics.withColumn(
		"characteristics_id",
        compute_uuid_udf(struct(*transformed_melt_characteristics.columns))
	)
