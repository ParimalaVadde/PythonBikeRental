Identify the vulnerability
Identify the type of vulnerability present in the code. Code blocks that are vulnerable are marked with warning icons (). Additional code blocks that may give context may be marked with lightbulb icons ().

Select Vulnerability Category
Unvalidated Redirects and Forwards

Unvalidated Redirects and Forwards

Denial of Service

Routing

Improper Assets Management

Improper Assets Management

Insecure Cryptography

Insufficiently Protected Credentials

Access Control

Insecure Direct Object Reference

Side Channel Vulnerability

Timing Attack       	





import json
import logging
from pathlib import Path
from config import BASE_DIR
from MySQLdb import MySQLError
from database.connect import Connect

from auth import Auth
from decorators import is_authorized
from serializers import UserUpdateSerializer, UserInsertSerializer

logger = logging.getLogger(__name__)


class User(Auth):

    @is_authorized
    def retrieve(self):

        result = None
        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT username, email, first_name, last_name
                FROM users WHERE id=%(id)s
                """, {'id': self.id}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the user record')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert(self, **kwargs):

        result = None
        roles = self.roles()
        if roles and not 'administrator' in roles:
            logger.error('Forbidden')
            return result

        password = kwargs.get('password')
        if password:
            kwargs.update(
                {'password': self.hasher.encode(password, self.hasher.salt())})

        columns, values = UserInsertSerializer().insertfields(kwargs)
        if not (columns and values):
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"""
                INSERT INTO users ({columns})
                VALUES ({values})
                """, kwargs
            )
            conn.db.commit()
            logger.info('User %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the user')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def update(self, **kwargs):

        result = None
        fields = UserUpdateSerializer().updatefields(kwargs)
        if not fields:
            return result
        kwargs.update({'id': self.id})

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"UPDATE users SET {fields} WHERE id=%(id)s", kwargs)
            conn.db.commit()
            result = cursor.rowcount

            if not result:
                raise MySQLError

        except MySQLError:
            logger.error('User could not be updated')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert_role(self, user_id, role_id):

        result = None
        roles = self.roles()
        if not (roles and 'administrator' in roles):
            logger.error('Forbidden')
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO user_roles (user_id, role_id)
                VALUES (%(user_id)s, %(role_id)s)
                """, {'user_id': user_id, 'role_id': role_id}
            )
            conn.db.commit()
            logger.info('User role %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the user role')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def load_roles(self, filename='roles.json'):

        result = None

        conn = Connect()
        try:
            with open(Path(BASE_DIR, filename), 'r') as file:
                roles = json.load(file)

            if not (roles and type(roles) is list):
                logger.error('JSON file could not be loaded')

            cursor = conn.db.cursor()
            cursor.executemany(
                'INSERT INTO roles (id, name) VALUES (%(id)s, %(name)s)',
                roles)
            conn.db.commit()
            logger.info('Roles %02d inserted' % cursor.lastrowid)
        except (OSError, ValueError, MySQLError) as e:
            logger.error(f'User roles could not be loaded: {e}')
        finally:
            conn.db.close()
        return result
