Locate the vulnerability
Review the highlighted code blocks in the source code and select 1 code block that causes the vulnerability listed below.

Vulnerability Category
Access Control - Insecure Direct Object Referenc

choose correct answer
Code blocks
appointments.py:17-21
appointments.py:48-52
appointments.py:78-82
auth.py:29-41
auth.py:77-83
roles.json:2-5
serializers.py:24-30
serializers.py:63-69
users.py:24-29
users.py:99-115
users.py:125-132


appointments.py

import logging
from MySQLdb import MySQLError
from database.connect import Connect

from auth import Auth
from decorators import is_authorized
from serializers import AppointmentSerializer

logger = logging.getLogger(__name__)


class Appointment(Auth):

    @is_authorized
    def retrieve(self, uuid):

        result = None
        roles = self.roles()
        if not (roles and ('administrator' in roles or 'staff' in roles)):
            logger.error('Forbidden')
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT
                    pets.name, pets.species,
                    reason, datetime, description,
                    users.first_name, users.last_name
                FROM appointments
                INNER JOIN pets ON pets.id=appointments.pet_id
                INNER JOIN users ON users.id=appointments.doctor_id
                WHERE uuid=UUID_TO_BIN(%(uuid)s)
                """, {'uuid': uuid}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the appointment')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert(self, user_id, **kwargs):

        result = None
        roles = self.roles(user_id)
        if not (roles and ('administrator' in roles or 'staff' in roles)):
            logger.error('Forbidden')
            return result

        columns, values = AppointmentSerializer().insertfields(kwargs)
        if not (columns and values):
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"""
                INSERT INTO appointments (uuid, {columns})
                VALUES (UUID_TO_BIN(UUID()), {values})
                """, kwargs
            )
            conn.db.commit()
            logger.info('Appointment %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the appointment')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def retrieve_client(self, uuid):

        result = None
        roles = self.roles()
        if not (roles and ('administrator' in roles or 'staff' in roles)):
            logger.error('Forbidden')
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT first_name, last_name, email, phone,
                    addresses.line_1, addresses.line_2, addresses.city,
                    addresses.state,
                FROM clients
                INNER JOIN addresses ON addresses.id=clients.address_id
                WHERE uuid=UUID_TO_BIN(%(uuid)s)
                """, {'uuid': uuid}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the client')
        finally:
            conn.db.close()
        return result
		
		
		

authy.py

import logging
import importlib
from datetime import datetime
from MySQLdb import MySQLError
from config import PASSWORD_HASHER
from database.connect import Connect

from decorators import is_authorized

logger = logging.getLogger(__name__)


class Auth:
    """User Authentication"""

    def __init__(self):

        self.id = None
        self.is_authenticate = False
        # load password hasher class from config file
        self.hasher = getattr(
            importlib.import_module('hashers'), PASSWORD_HASHER)()

    def login(self, username, password):

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT id, password FROM users
                WHERE username=%(username)s
                """, {'username': username}
            )
            result = cursor.fetchone()

            if not (result and self.hasher.verify(password, result[1])):
                raise MySQLError

            self.is_authenticate = True
            self.id = result[0]

            cursor.execute(
                """
                UPDATE users
                SET last_login=%(last_login)s
                WHERE id=%(id)s
                """,
                {
                    'last_login': datetime.now(),
                    'id': self.id
                }
            )
            conn.db.commit()
            result = cursor.rowcount

            if not result:
                logger.error('Last login could not be updated')

        except Exception:
            logger.error('Login authorization failure')
        finally:
            conn.db.close()

    def logout(self):

        self.id = None
        self.is_authenticate = False

    @is_authorized
    def roles(self):

        result = None
        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT name FROM roles
                INNER JOIN user_roles ON roles.id = user_roles.role_id
                WHERE user_roles.user_id = %(user_id)s
                """, {'user_id': self.id}
            )
            result = [role[0] for role in cursor.fetchall()]
        except MySQLError:
            logger.error('Could not retrieve the user record')
        finally:
            conn.db.close()
        return result
		
		
		
		
roles.json
[
    {"id": 1, "name": "administrator"},
    {"id": 2, "name": "veterinarian"},
    {"id": 3, "name": "business"},
    {"id": 4, "name": "staff"}
]



serializers.py


import logging

logger = logging.getLogger(__name__)


class UpdateSerializer:

    fields = None

    def serialize(self, data):

        result = ''

        if self.fields:
            field = self.fields[0]
            if data.get(field):
                result += f'{field}=%({field})s'
            for field in self.fields[1:]:
                if data.get(field):
                    result += f', {field}=%({field})s'

        return result

    def updatefields(self, data):

        if not (data and isinstance(data, dict)):
            logger.error('SerializerError: data is not valid')
            return None

        return self.serialize(data)


class UserUpdateSerializer(UpdateSerializer):

    fields = ['first_name', 'last_name', 'email']


class ClientSerializer(UpdateSerializer):

    fields = ['first_name', 'last_name', 'email', 'phone']


class InsertSerializer:

    fields = None

    def serialize(self, data):

        columns, values = '', ''

        if self.fields:
            field = self.fields[0]
            if data.get(field):
                columns += f'{field}'
                values += f'%({field})s'
            for field in self.fields[1:]:
                if data.get(field):
                    columns += f', {field}'
                    values += f', %({field})s'

        return columns, values

    def insertfields(self, data):

        if not (data and isinstance(data, dict)):
            logger.error('SerializerError: data is not valid')
            return None

        return self.serialize(data)


class UserInsertSerializer(InsertSerializer):

    fields = ['username', 'password', 'email']


class AppointmentSerializer(InsertSerializer):

    fields = ['pet_id', 'reason', 'datetime', 'description', 'doctor_id']


class AddressSerializer(InsertSerializer):

    fields = ['line_1', 'line_2', 'city', 'state']
	

users.py

import json
import logging
from pathlib import Path
from config import BASE_DIR
from MySQLdb import MySQLError
from database.connect import Connect

from auth import Auth
from decorators import is_authorized
from serializers import UserUpdateSerializer, UserInsertSerializer

logger = logging.getLogger(__name__)


class User(Auth):

    @is_authorized
    def retrieve(self):

        result = None
        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT username, email, first_name, last_name
                FROM users WHERE id=%(id)s
                """, {'id': self.id}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the user record')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert(self, **kwargs):

        result = None
        roles = self.roles()
        if roles and not 'administrator' in roles:
            logger.error('Forbidden')
            return result

        password = kwargs.get('password')
        if password:
            kwargs.update(
                {'password': self.hasher.encode(password, self.hasher.salt())})

        columns, values = UserInsertSerializer().insertfields(kwargs)
        if not (columns and values):
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"""
                INSERT INTO users ({columns})
                VALUES ({values})
                """, kwargs
            )
            conn.db.commit()
            logger.info('User %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the user')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def update(self, **kwargs):

        result = None
        fields = UserUpdateSerializer().updatefields(kwargs)
        if not fields:
            return result
        kwargs.update({'id': self.id})

        conn = Connect()
        try:
            cursor = conn.db.cursor()
	
