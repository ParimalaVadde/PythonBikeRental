Identify the vulnerability
Identify the type of vulnerability present in the code. Code blocks that are vulnerable are marked with warning icons (). Additional code blocks that may give context may be marked with lightbulb icons ().

Select Vulnerability Category
Side Channel Vulnerability

Clipboard buffer caching

Vulnerable Components

CVE-2021-44832 (Log4j)

Security Misconfiguration

Information Exposure

Side Channel Vulnerability

Data sent to 3rd parties (analytics, error handling)




clients.py


import yaml
import logging
import traceback
import importlib
from MySQLdb import MySQLError
from config import PASSWORD_HASHER
from database.connect import Connect
import defusedxml.ElementTree as etree

logger = logging.getLogger(__name__)


class Client:

    def __init__(self):

        self.is_authenticate = False
        # load password hasher class
        self.hasher = getattr(
            importlib.import_module('hashers'), PASSWORD_HASHER)()

    def authenticate(self, username, password):

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT id, password FROM client
                WHERE username=%(username)s
                """, {'username': username}
            )
            result = cursor.fetchone()

            if not result:
                raise MySQLError

            if self.hasher.verify(password, result[1]):
                self.is_authenticate = True

        except Exception:
            logger.error('Client authorization failure')
            raise MySQLError('Client authorization failure')
        finally:
            conn.db.close()

    def retrieve(self, username):

        result = None
        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT * FROM client WHERE username=%(username)s
                """, {'username': username}
            )
            result = cursor.fetchone()
        except Exception as e:
            logger.error('Could not retrieve the records: %s' % e)
            return '{} {}'.format(e, traceback.format_exc())
        finally:
            conn.db.close()
        return result

    def insert(self, client):

        drivers_license_number = client.get('drivers_license_number')
        if drivers_license_number:
            drivers_license_number = self.hasher.encode(drivers_license_number, self.hasher.salt())

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.get('username'),
                    'password': self.hasher.encode(
                        client.get('password'), self.hasher.salt()),
                    'first_name': client.get('first_name'),
                    'last_name': client.get('last_name'),
                    'drivers_license_number': drivers_license_number,
                    'email': client.get('email'),
                    'description': client.get('description')
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def insert_from_xml(self, client_xml):

        parser = etree.DefusedXMLParser(
            # disallow XML with a <!DOCTYPE> processing instruction
            forbid_dtd=True,
            # disallow XML with <!ENTITY> declarations inside the DTD
            forbid_entities=True,
            # disallow any access to remote or local resources in external entities or DTD
            forbid_external=True
        )

        try:
            tree = etree.parse(client_xml, parser=parser)
        except (etree.ParseError, ValueError) as e:
            logger.error('XML parse error - %s' % e)
            raise e
        client = tree.getroot()

        drivers_license_number = client.find('drivers_license_number')
        if drivers_license_number is not None:
            drivers_license_number = self.hasher.encode(drivers_license_number.text, self.hasher.salt())

        description = client.find('description')
        if description is not None:
            description = description.text

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.find('username').text,
                    'password': self.hasher.encode(
                        client.find('password').text, self.hasher.salt()),
                    'first_name': client.find('first_name').text,
                    'last_name': client.find('last_name').text,
                    'drivers_license_number': drivers_license_number,
                    'email': client.find('email').text,
                    'description': description
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def insert_from_yaml(self, client_yaml):

        with open(client_yaml, 'r') as stream:
            client = yaml.safe_load(stream)

        if type(client) is not dict:
            e = ValueError('File %s could not be loaded.' % client_yaml)
            logger.error('%s' % e)
            raise e

        drivers_license_number = client.get('drivers_license_number')
        if drivers_license_number:
            drivers_license_number = self.hasher.encode(drivers_license_number, self.hasher.salt())

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.get('username'),
                    'password': self.hasher.encode(
                        client.get('password'), self.hasher.salt()),
                    'first_name': client.get('first_name'),
                    'last_name': client.get('last_name'),
                    'drivers_license_number': drivers_license_number,
                    'email': client.get('email'),
                    'description': client.get('description')
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def delete(self, client_id):
        try:
            conn = Connect()
            result = conn.db.cursor().execute(
                """
                DELETE FROM client WHERE id=%(id)s
                """, {'id': client_id}
            )
            conn.db.commit()
            if result:
                logger.warning('Client id %02d deleted' % client_id)
            else:
                logger.warning('Client does not exist')
        except MySQLError as e:
            logger.error('Could not delete client: %s' % e)
        finally:
            conn.db.close()
