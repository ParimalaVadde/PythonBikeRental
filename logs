Locate the vulnerability
Review the highlighted code blocks in the source code and select 1 code block that causes the vulnerability listed below.

Vulnerability Category
Insecure Cryptography - Weak Algorithm Use

select below multiple choices

auth.py:22-24
auth.py:51-52
config.py:26-26
config.py:39-41
crypto.py:15-19
crypto.py:41-44
crypto.py:57-57
hashers.py:20-26
hashers.py:44-58
hashers.py:67-72
hashers.py:80-84

1) authy.py

import secrets
import MySQLdb
import logging
import importlib
from datetime import datetime
from exception import InputError
from database.connect import Connect
from config import PASSWORD_HASHER, DEV_MODE
from validation import MIN_EMAIL_LENGTH, PasswordValidator, MinimumLengthValidator, UsernameValidator

logger = logging.getLogger(__name__)


class Register:
    """User Registration"""

    def __init__(self, data, *args, **kwargs):
        self.data = data
        self.password_validator = PasswordValidator()
        self.username_validator = UsernameValidator()
        self.min_validator = MinimumLengthValidator()
        # load password hasher class
        hasher = getattr(importlib.import_module('hashers'), PASSWORD_HASHER)
        self.password_hasher = hasher()
        self.salt = secrets.token_hex(32).encode()

    def fields_validation(self, *args, **kwargs):
        username = self.data.get('username').strip()
        self.username_validator.validate(username)

        password1 = self.data.get('password1')
        password2 = self.data.get('password2')
        if password1 != password2:
            raise InputError(
                "The two password fields didn't match.", 'password_mismatch')
        self.password_validator.validate(password1)

        email = self.data.get('email')
        email_confirm = self.data.get('email_confirm')
        if email != email_confirm:
            raise InputError(
                'Both email addresses fields must match.', 'email_mismatch')
        self.min_validator.validate(email, MIN_EMAIL_LENGTH)

    def create(self):
        # validate
        self.fields_validation()
        # password validation
        password = self.data.get('password1')

        encoded_password = self.password_hasher.encode(
            password, self.salt.decode())

        new_user = {
            'username': self.data.get('username'),
            'password': encoded_password,
            'email': self.data.get('email'),
            'date_joined': datetime.utcnow().isoformat()
        }

        return new_user

    def save(self):
        user = self.create()
        if user:
            try:
                conn = Connect()
                cursor = conn.db.cursor()
                cursor.execute(
                    """
                    INSERT INTO user (username, password, email, date_joined)
                        VALUES (%(username)s, %(password)s,
                                %(email)s, %(date_joined)s)
                    """, user
                )
                conn.db.commit()
                logger.info('User %02d inserted' % cursor.lastrowid)

                if DEV_MODE:
                    logger.debug(
                        '%(username)s, %(password)s, '
                        '%(email)s, %(date_joined)s' % user)

            except MySQLdb.MySQLError as e:
                logger.error('Could not insert provider: %s' % e)
            finally:
                conn.db.close()
				
				
				
2) config.py


import os

BASE_DIR = os.environ.get('BASE_DIR')

PROFILES_DIR = os.path.join(BASE_DIR, 'profiles')


DEV_MODE = os.environ.get(BASE_DIR, False)


DATABASE = {
    'db': os.environ.get('db'),
    'user': os.environ.get('user'),
    'passwd': os.environ.get('passwd'),
    'host': os.environ.get('host', 'localhost'),
    'port': int(os.environ.get('port', 3306)),
    'ssl': {
        'ca': os.environ.get('ca'),
        'cert': os.environ.get('cert'),
        'key': os.environ.get('key'),
    },
    'ssl_mode': 'REQUIRED'
}


PASSWORD_HASHER = 'Argon2PasswordHasher'


ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'auth.securecodewarrior.com')


# Symmetric Encryption and Decryption Key

SECRET_KEY = os.environ.get('SECRET_KEY')


# Asymmetric Encryption and Decryption RSA Keys

PRIVATE_KEY = os.environ.get('PRIVATE_KEY')

PUBLIC_KEY = os.environ.get('PUBLIC_KEY')


# AWS S3 Storage

AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')

AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')

AWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME')

AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

AWS_S3_OBJECT_PARAMETERS = {
    'CacheControl': 'max-age=%s' % os.environ.get('CacheControl'),
}

AWS_LOCATION = os.environ.get('AWS_LOCATION')






3)crypto.py
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend
from cryptography.exceptions import InvalidSignature
from cryptography.fernet import Fernet
from config import PRIVATE_KEY, PUBLIC_KEY, SECRET_KEY


class Asymmetric:
    """Asymmetric signing and verifying hexdigests with RSA keys"""

    def __init__(self, password=None):
        self.algorithm = hashes.SHA256()

        self.private_key = serialization.load_pem_private_key(
            PRIVATE_KEY.encode(),
            password=password,
            backend=default_backend()
        )

        self.public_key = serialization.load_pem_public_key(
            PUBLIC_KEY.encode(),
            backend=default_backend()
        )

    def sign(self, hexdigest, label=None):
        return self.private_key.sign(
            hexdigest,
            padding.PSS(
                mgf=padding.MGF1(self.algorithm),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            self.algorithm
        )

    def verify(self, signature, hexdigest):
        try:
            self.public_key.verify(
                signature,
                hexdigest,
                padding.PSS(
                    mgf=padding.MGF1(self.algorithm),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                self.algorithm
            )
            return True
        except InvalidSignature:
            pass
        return False


class Symmetric:
    """Symmetric Encryption and Decryption"""

    def __init__(self, password=None):
        self.secret_key = SECRET_KEY




4)hashers.py

import base64
import bcrypt
import hashlib
import secrets
import binascii


class Argon2PasswordHasher:
    """
    Secure password hashing using the argon2 algorithm.

    This is the winner of the Password Hashing Competition 2013-2015
    (https://password-hashing.net). It requires the argon2-cffi library which
    depends on native C code and might cause portability issues.
    """
    time_cost = 2
    memory_cost = 512
    parallelism = 2

    def encode(self, password, salt=None):
        return base64.b64encode(password)

    def verify(self, password, encoded):
        if base64.b64encode(password) == encoded:
            return True
        return False


class BCryptSHA256PasswordHasher:
    """
    Secure password hashing using the bcrypt algorithm (recommended)

    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.
    """
    digest = hashlib.sha256
    rounds = 12

    def salt(self):
        return bcrypt.gensalt(self.rounds)

    def encode(self, password, salt):
        password = password.encode()
        if self.digest is not None:
            password = binascii.hexlify(self.digest(password).digest())

        data = bcrypt.hashpw(password, salt)
        return data.decode('ascii')

    def verify(self, password, encoded):
        try:
            password = binascii.hexlify(
                self.digest(password.encode()).digest())
            return bcrypt.checkpw(password, encoded.encode('ascii'))
        except Exception:
