this is the data i hv in db for sds_staging.business_entity_relationships table

business_entity_relationship_id	stg_business_entity_id	business_entity_contact_id	stg_related_business_entity_id	related_business_entity_contact_id	business_entity_role	related_business_entity_role	is_active	created_by	created_date
b15b26f8-1fc8-d50a-28aa-44c5ed97e874	9627106c-b400-cc56-9a9c-5ca465375b74	821c9632-5325-5e18-abe8-3e7dd798360f	bb47d9f7-c631-a592-a734-8221082535bf	NULL	supplier	buyer	TRUE	PFD	8/22/2025 0:00
9ab64ff5-3bd0-08a0-11a6-f494cd1e0600	c685f21a-d615-1c95-61eb-5cdeae6a7e13	897e65e1-8b6f-0910-d318-ce18db5de87c	bb47d9f7-c631-a592-a734-8221082535bf	NULL	supplier	buyer	TRUE	PFD	8/22/2025 0:00
76d0bdd5-a51d-b795-d3bd-007d39406593	d4d2ab49-d5a2-0ee5-15f2-b277c576d2dd	c0104c78-0c03-1489-64b2-1372a2a10300	bb47d9f7-c631-a592-a734-8221082535bf	NULL	supplier	buyer	TRUE	PFD	8/22/2025 0:00
f5de1f07-69ad-9985-5c92-9ad3824e4540	bb47d9f7-c631-a592-a734-8221082535bf	NULL	2d35a04a-5fdf-50d5-7750-c1c7621ddc33	NULL	client	firm	TRUE	PFD	8/22/2025 0:00
be7ad78b-cff7-8af3-b093-a02b1535fd30	156abc41-20a9-4efc-0575-4aded2d804af	a5f815b2-4c1b-dbad-97f0-1652b7daed0f	bb47d9f7-c631-a592-a734-8221082535bf	NULL	supplier	buyer	TRUE	PFD	8/22/2025 0:00


i wnat to get stg_business_entity_id which has more than one business_entity_contact_id

for example
output should be like tis
stg_business_entity_id                    business_entity_contact_id
9627106c-b400-cc56-9a9c-5ca465375b74		821c9632-5325-5e18-abe8-3e7dd798360f
9627106c-b400-cc56-9a9c-5ca465375b74		821c9632-5325-5e18-abe8-3e7dd798360f

***************************************************

SELECT 
    stg_business_entity_id, 
    business_entity_contact_id
FROM 
    sds_staging.business_entity_relationships
WHERE 
    stg_business_entity_id IN (
        SELECT 
            stg_business_entity_id
        FROM 
            sds_staging.business_entity_relationships
        WHERE 
            business_entity_contact_id IS NOT NULL
        GROUP BY 
            stg_business_entity_id
        HAVING 
            COUNT(DISTINCT business_entity_contact_id) > 1
    )
ORDER BY 
    stg_business_entity_id;


*********************************************************************************************************************


# Transform contacts from associated_people data
people_contacts = (transformed_json_df
              .select(*ss.contacts)
              .distinct()
              .filter(
                  (col("associated_people__name").isNotNull() & 
                   (trim(col("associated_people__name")) != "") & 
                   (col("associated_people__name") != "none")) |
                  (col("associated_people__titles").isNotNull() & 
                   (trim(col("associated_people__titles")) != "") & 
                   (col("associated_people__titles") != "none"))
              )
              .withColumnRenamed("associated_people__name", "contact_name")
              .withColumnRenamed("associated_people__titles", "contact_title"))

# Process vendor contacts - ONLY if vendor_contact_name is not null
vendor_contacts_raw = transformed_df.select(*ss.vendor_contact).distinct()
vendor_contacts_filtered = vendor_contacts_raw.filter(col("vendor_contact_name").isNotNull())

# Check if there are any non-null vendor contacts
vendor_contact_count = vendor_contacts_filtered.count()

if vendor_contact_count > 0:
    vendor_contacts_final = vendor_contacts_filtered.select(
        col("stg_business_entity_id"),
        col("vendor_contact_name").alias("contact_name"),
        lit(None).cast("string").alias("contact_title")
    )
    # Union the two dataframes
    all_contacts = people_contacts.unionByName(vendor_contacts_final)
else:
    #Use only the people contacts data
    all_contacts = people_contacts

# Only keep contacts that actually have contact names
transformed_contacts = all_contacts.filter(col("contact_name").isNotNull())

transformed_contacts = transformed_contacts.withColumn(
"is_active", 
lit(True)  # This creates a Boolean column with True values for all rows
)

# Generate UUIDs only for valid contacts
if transformed_contacts.count() > 0:
    transformed_contacts = transformed_contacts.withColumn(
        "business_entity_contact_id",
        compute_uuid_udf(struct(*transformed_contacts.columns))
    )
    
    
    
i need some changes in above 
wat means 
in people_contacts if same contact_name is in vendor_contacts_final then we have consider people_contacts record not contact_name

how we make these changes efficiently

***********************************************************************************************************

# Transform contacts from associated_people data
people_contacts = (transformed_json_df
              .select(*ss.contacts)
              .distinct()
              .filter(
                  (col("associated_people__name").isNotNull() & 
                   (trim(col("associated_people__name")) != "") & 
                   (col("associated_people__name") != "none")) |
                  (col("associated_people__titles").isNotNull() & 
                   (trim(col("associated_people__titles")) != "") & 
                   (col("associated_people__titles") != "none"))
              )
              .withColumnRenamed("associated_people__name", "contact_name")
              .withColumnRenamed("associated_people__titles", "contact_title"))

# Process vendor contacts - ONLY if vendor_contact_name is not null
vendor_contacts_raw = transformed_df.select(*ss.vendor_contact).distinct()
vendor_contacts_filtered = vendor_contacts_raw.filter(col("vendor_contact_name").isNotNull())

# Check if there are any non-null vendor contacts
vendor_contact_count = vendor_contacts_filtered.count()

if vendor_contact_count > 0:
    vendor_contacts_prepared = vendor_contacts_filtered.select(
        col("stg_business_entity_id"),
        col("vendor_contact_name").alias("contact_name"),
        lit(None).cast("string").alias("contact_title")
    )
    
    # This compares using uppercase but keeps original case in final data
    people_contact_names_upper = people_contacts.select(upper(col("contact_name")).alias("contact_name_upper")).distinct()
    
    unique_vendor_contacts = vendor_contacts_prepared.join(
         people_contact_names_upper,
         upper(col("contact_name")) == col("contact_name_upper"),
         how="left_anti"
     )
     # The original contact_name column remains unchanged
    
    # Union people_contacts (priority) with unique vendor contacts
    all_contacts = people_contacts.unionByName(unique_vendor_contacts)
else:
    # Use only the people contacts data
    all_contacts = people_contacts

# Only keep contacts that actually have contact names
transformed_contacts = all_contacts.filter(col("contact_name").isNotNull())

transformed_contacts = transformed_contacts.withColumn(
    "is_active", 
    lit(True)  # This creates a Boolean column with True values for all rows
)

# Generate UUIDs only for valid contacts
if transformed_contacts.count() > 0:
    transformed_contacts = transformed_contacts.withColumn(
        "business_entity_contact_id",
        compute_uuid_udf(struct(*transformed_contacts.columns))
    )
