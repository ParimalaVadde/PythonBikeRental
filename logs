Locate the vulnerability
Review the highlighted code blocks in the source code and select 1 code block that causes the vulnerability listed below.

Vulnerability Category
Access Control - Insecure Direct Object Reference

Learn More


Code blocks
appointments.py:46-66
appointments.py:75-98
users.py:18-29
users.py:38-63

appointments.py

import logging
from MySQLdb import MySQLError
from database.connect import Connect

from auth import Auth
from decorators import is_authorized
from serializers import AppointmentSerializer

logger = logging.getLogger(__name__)


class Appointment(Auth):

    @is_authorized
    def retrieve(self, uuid):

        result = None
        roles = self.roles()
        if not (roles and ('administrator' in roles or 'staff' in roles)):
            logger.error('Forbidden')
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT
                    pets.name, pets.species,
                    reason, datetime, description,
                    users.first_name, users.last_name
                FROM appointments
                INNER JOIN pets ON pets.id=appointments.pet_id
                INNER JOIN users ON users.id=appointments.doctor_id
                WHERE uuid=UUID_TO_BIN(%(uuid)s)
                """, {'uuid': uuid}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the appointment')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert(self, user_id, **kwargs):

        result = None
        roles = self.roles(user_id)
        if not (roles and ('administrator' in roles or 'staff' in roles)):
            logger.error('Forbidden')
            return result

        columns, values = AppointmentSerializer().insertfields(kwargs)
        if not (columns and values):
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"""
                INSERT INTO appointments (uuid, {columns})
                VALUES (UUID_TO_BIN(UUID()), {values})
                """, kwargs
            )
            conn.db.commit()
            logger.info('Appointment %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the appointment')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def retrieve_client(self, id):

        result = None

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT first_name, last_name, email, phone,
                    addresses.line_1, addresses.line_2, addresses.city,
                    addresses.state,
                FROM clients
                INNER JOIN addresses ON addresses.id=clients.address_id
                WHERE id=%(id)s
                """, {'id': id}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the client')
        finally:
            conn.db.close()
        return result
		
		
		
		
users.py

import json
import logging
from pathlib import Path
from config import BASE_DIR
from MySQLdb import MySQLError
from database.connect import Connect

from auth import Auth
from decorators import is_authorized
from serializers import UserUpdateSerializer, UserInsertSerializer

logger = logging.getLogger(__name__)


class User(Auth):

    @is_authorized
    def retrieve(self):

        result = None
        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT username, email, first_name, last_name
                FROM users WHERE id=%(id)s
                """, {'id': self.id}
            )
            result = cursor.fetchone()
        except MySQLError:
            logger.error('Could not retrieve the user record')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def insert(self, **kwargs):

        result = None
        roles = self.roles()
        if roles and not 'administrator' in roles:
            logger.error('Forbidden')
            return result

        password = kwargs.get('password')
        if password:
            kwargs.update(
                {'password': self.hasher.encode(password, self.hasher.salt())})

        columns, values = UserInsertSerializer().insertfields(kwargs)
        if not (columns and values):
            return result

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"""
                INSERT INTO users ({columns})
                VALUES ({values})
                """, kwargs
            )
            conn.db.commit()
            logger.info('User %02d inserted' % cursor.lastrowid)
        except MySQLError:
            logger.error('Could not insert the user')
        finally:
            conn.db.close()
        return result

    @is_authorized
    def update(self, **kwargs):

        result = None
        fields = UserUpdateSerializer().updatefields(kwargs)
        if not fields:
            return result
        kwargs.update({'id': self.id})

        conn = Connect()
        try:
            cursor = conn.db.cursor()
            cursor.execute(
                f"UPDATE users SET {fields} WHERE id=%(id)s", kwargs)
            conn.db.commit()
            result = cursor.rowcount

            if not result:
                raise MySQLError

        except MySQLError:
            logger.error('User could not be updated')
        finally:
            conn.db.close()
        return result

    @is_authorized
