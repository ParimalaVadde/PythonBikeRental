Locate the vulnerability
Review the highlighted code blocks in the source code and select 1 code block that causes the vulnerability listed below.

Vulnerability Category
Security Misconfiguration - Information Exposure

Learn More

select correct options
Code blocks
clients.py:61-61
clients.py:115-116
clients.py:162-163
vehicles.py:24-24


1) clients.py


import yaml
import logging
import traceback
import importlib
from MySQLdb import MySQLError
from config import PASSWORD_HASHER
from database.connect import Connect
import defusedxml.ElementTree as etree

logger = logging.getLogger(__name__)


class Client:

    def __init__(self):

        self.is_authenticate = False
        # load password hasher class
        self.hasher = getattr(
            importlib.import_module('hashers'), PASSWORD_HASHER)()

    def authenticate(self, username, password):

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT id, password FROM client
                WHERE username=%(username)s
                """, {'username': username}
            )
            result = cursor.fetchone()

            if not result:
                raise MySQLError

            if self.hasher.verify(password, result[1]):
                self.is_authenticate = True

        except Exception:
            logger.error('Client authorization failure')
            raise MySQLError('Client authorization failure')
        finally:
            conn.db.close()

    def retrieve(self, username):

        result = None
        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                SELECT * FROM client WHERE username=%(username)s
                """, {'username': username}
            )
            result = cursor.fetchone()
        except Exception as e:
            logger.error('Could not retrieve the records: %s' % e)
            return '{} {}'.format(e, traceback.format_exc())
        finally:
            conn.db.close()
        return result

    def insert(self, client):

        drivers_license_number = client.get('drivers_license_number')
        if drivers_license_number:
            drivers_license_number = self.hasher.encode(drivers_license_number, self.hasher.salt())

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.get('username'),
                    'password': self.hasher.encode(
                        client.get('password'), self.hasher.salt()),
                    'first_name': client.get('first_name'),
                    'last_name': client.get('last_name'),
                    'drivers_license_number': drivers_license_number,
                    'email': client.get('email'),
                    'description': client.get('description')
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def insert_from_xml(self, client_xml):

        parser = etree.DefusedXMLParser(
            # disallow XML with a <!DOCTYPE> processing instruction
            forbid_dtd=True,
            # disallow XML with <!ENTITY> declarations inside the DTD
            forbid_entities=True,
            # disallow any access to remote or local resources in external entities or DTD
            forbid_external=True
        )

        try:
            tree = etree.parse(client_xml, parser=parser)
        except (etree.ParseError, ValueError) as e:
            logger.error('XML parse error - %s' % e)
            raise e
        client = tree.getroot()

        drivers_license_number = client.find('drivers_license_number')
        if drivers_license_number is not None:
            drivers_license_number = self.hasher.encode(drivers_license_number.text, self.hasher.salt())

        description = client.find('description')
        if description is not None:
            description = description.text

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.find('username').text,
                    'password': self.hasher.encode(
                        client.find('password').text, self.hasher.salt()),
                    'first_name': client.find('first_name').text,
                    'last_name': client.find('last_name').text,
                    'drivers_license_number': drivers_license_number,
                    'email': client.find('email').text,
                    'description': description
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def insert_from_yaml(self, client_yaml):

        with open(client_yaml, 'r') as stream:
            client = yaml.safe_load(stream)

        if type(client) is not dict:
            e = ValueError('File %s could not be loaded.' % client_yaml)
            logger.error('%s' % e)
            raise e

        drivers_license_number = client.get('drivers_license_number')
        if drivers_license_number:
            drivers_license_number = self.hasher.encode(drivers_license_number, self.hasher.salt())

        try:
            conn = Connect()
            cursor = conn.db.cursor()
            cursor.execute(
                """
                INSERT INTO client (username, password,
                    first_name, last_name, drivers_license_number, email, description)
                    VALUES (%(username)s, %(password)s, %(first_name)s,
                            %(last_name)s, %(drivers_license_number)s, %(email)s,
                            %(description)s)
                """,
                {
                    'username': client.get('username'),
                    'password': self.hasher.encode(
                        client.get('password'), self.hasher.salt()),
                    'first_name': client.get('first_name'),
                    'last_name': client.get('last_name'),
                    'drivers_license_number': drivers_license_number,
                    'email': client.get('email'),
                    'description': client.get('description')
                }
            )
            conn.db.commit()
            logger.info('Client %02d inserted' % cursor.lastrowid)
        except MySQLError as e:
            logger.error('Could not insert client: %s' % e)
        finally:
            conn.db.close()

    def delete(self, client_id):
        try:
            conn = Connect()
            result = conn.db.cursor().execute(
                """
                DELETE FROM client WHERE id=%(id)s
                """, {'id': client_id}
            )
            conn.db.commit()
            if result:
                logger.warning('Client id %02d deleted' % client_id)
            else:
                logger.warning('Client does not exist')
        except MySQLError as e:
            logger.error('Could not delete client: %s' % e)
        finally:
            conn.db.close()
			
			
			
			
			
2)vehicles.py


import pymongo
import logging
from mongo.connect import MongoConnection

logger = logging.getLogger(__name__)


class Vehicle:

    def insert(self, vehicle):

        try:
            conn = MongoConnection()

            conn.db.vehicles.insert({
                'client_id': vehicle.get('client_id'),
                'plate': vehicle.get('plate'),
                'color': vehicle.get('color'),
                'category': vehicle.get('category'),
                'description': vehicle.get('description'),
                'is_allowed': True
            })
        except pymongo.errors.PyMongoError as e:
            logger.error('Could not save the vehicle: %s' % e)
        finally:
            conn.client.close()

    def find(self, client_id, plate):
        results = []
        try:
            conn = MongoConnection()
            if type(client_id) is not int:
                raise AttributeError(plate)
            cursor = conn.db.vehicles.find({
                "client_id": client_id,
                "plate": {
                    "$regex": plate,
                    "$options": "i"
                }
            })
            results = [vehicles for vehicles in cursor]
            cursor.close()
        except (pymongo.errors.PyMongoError, AttributeError) as e:
            logger.error('Could not find the vehicle: %s' % e)
        finally:
            conn.client.close()
        return results
		
		
		
