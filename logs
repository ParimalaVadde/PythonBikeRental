Locate the vulnerability
Review the highlighted code blocks in the source code and select 1 code block that causes the vulnerability listed below.

Vulnerability Category
Insecure Cryptography - Weak Algorithm Use

Code blocks
auth.py:49-49
auth.py:69-75
config.py:26-26
config.py:34-34

authy.py


import secrets
import MySQLdb
import logging
import importlib
from datetime import datetime
from exception import InputError
from database.connect import Connect
from config import PASSWORD_HASHER, DEV_MODE
from validation import MIN_EMAIL_LENGTH, PasswordValidator, MinimumLengthValidator, UsernameValidator

logger = logging.getLogger(__name__)


class Register:
    """User Registration"""

    def __init__(self, data, *args, **kwargs):
        self.data = data
        self.password_validator = PasswordValidator()
        self.username_validator = UsernameValidator()
        self.min_validator = MinimumLengthValidator()
        # load password hasher class
        hasher = getattr(importlib.import_module('hashers'), PASSWORD_HASHER)
        self.password_hasher = hasher()
        self.salt = secrets.token_hex(32).encode()

    def fields_validation(self, *args, **kwargs):
        username = self.data.get('username').strip()
        self.username_validator.validate(username)

        password1 = self.data.get('password1')
        password2 = self.data.get('password2')
        if password1 != password2:
            raise InputError(
                "The two password fields didn't match.", 'password_mismatch')
        self.password_validator.validate(password1)

        email = self.data.get('email')
        email_confirm = self.data.get('email_confirm')
        if email != email_confirm:
            raise InputError(
                'Both email addresses fields must match.', 'email_mismatch')
        self.min_validator.validate(email, MIN_EMAIL_LENGTH)

    def create(self):
        # validate
        self.fields_validation()
        # password validation
        password = self.data.get('password1')

        encoded_password = self.password_hasher.encode(
            password)

        new_user = {
            'username': self.data.get('username'),
            'password': encoded_password,
            'email': self.data.get('email'),
            'date_joined': datetime.utcnow().isoformat()
        }

        return new_user

    def save(self):
        user = self.create()
        if user:
            try:
                conn = Connect()
                cursor = conn.db.cursor()
                cursor.execute(
                    """
                    INSERT INTO user (username, password, email, date_joined)
                        VALUES (%(username)s, %(password)s,
                                %(email)s, %(date_joined)s)
                    """, user
                )
                conn.db.commit()
                logger.info('User %02d inserted' % cursor.lastrowid)

                if DEV_MODE:
                    logger.debug(
                        '%(username)s, %(password)s, '
                        '%(email)s, %(date_joined)s' % user)

            except MySQLdb.MySQLError as e:
                logger.error('Could not insert provider: %s' % e)
            finally:
                conn.db.close()
				
				


config.py


import os

BASE_DIR = os.environ.get('BASE_DIR')

PROFILES_DIR = os.path.join(BASE_DIR, 'profiles')


DEV_MODE = os.environ.get(BASE_DIR, False)


DATABASE = {
    'db': os.environ.get('db'),
    'user': os.environ.get('user'),
    'passwd': os.environ.get('passwd'),
    'host': os.environ.get('host', 'localhost'),
    'port': int(os.environ.get('port', 3306)),
    'ssl': {
        'ca': os.environ.get('ca'),
        'cert': os.environ.get('cert'),
        'key': os.environ.get('key'),
    },
    'ssl_mode': 'REQUIRED'
}


PASSWORD_HASHER = 'UnsaltedMD5PasswordHasher'


ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'auth.securecodewarrior.com')


# Symmetric Encryption and Decryption Key

SECRET_KEY = os.environ.get('SECRET_KEY')


# Asymmetric Encryption and Decryption RSA Keys

PRIVATE_KEY = os.environ.get('PRIVATE_KEY')

PUBLIC_KEY = os.environ.get('PUBLIC_KEY')


# AWS S3 Storage

AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')

AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')

AWS_STORAGE_BUCKET_NAME = os.environ.get('AWS_STORAGE_BUCKET_NAME')

AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

AWS_S3_OBJECT_PARAMETERS = {
    'CacheControl': 'max-age=%s' % os.environ.get('CacheControl'),
}

AWS_LOCATION = os.environ.get('AWS_LOCATION')
