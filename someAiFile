# Define a UDF to compute UUID from concatenated column values
def compute_uuid(data_row, decimal_columns):
    values = []
    
    # Convert Row object to dictionary
    data = data_row.asDict()
    # Sort by column names to ensure consistent order
    for column in sorted(data.keys()):
        val = data[column]
        if val is not None and str(val).strip().lower() not in {"", "nan", "null", "none", "nat"}:
            if column in decimal_columns:
                val = f"{float(val):.6f}"
            values.append(str(val).strip().lower())
    
    name = ','.join(values)
    return str(uuid.UUID(bytes=hashlib.md5(name.encode()).digest())) if name else None



******************************************************************************************************************************************************************************************





# Call the `relationship` function and assign the result to `transformed_relationship`
transformed_relationship = relationship(transformed_business_entity, transformed_contacts, transformed_df)

transformed_relationship = transformed_relationship.withColumn(
    "is_active", 
    lit(True)  # This creates a Boolean column with True values for all rows
)

print("********************relationship***************************************")
print(sorted(transformed_relationship.columns))
print("**********************************************************************************")

# Check for void data types before proceeding
print("Data types in transformed_relationship:")
for col_name, col_type in transformed_relationship.dtypes:
    print(f"{col_name}: {col_type}")

# Find columns with void data type
void_columns = [col_name for col_name, col_type in transformed_relationship.dtypes if col_type == 'void']
print(f"Void columns found: {void_columns}")

if void_columns:
    print(f"Fixing void columns: {void_columns}")
    for void_col in void_columns:
        transformed_relationship = transformed_relationship.withColumn(
            void_col, 
            lit(None).cast(StringType())  # Cast void to nullable string
        )

transformed_relationship_columns = [
    col for col in transformed_relationship.columns 
    if col not in ['client_ecid', 'client_vendor_id', 'client_vendor_site_id']
]

transformed_relationship = transformed_relationship.withColumn(
    "business_entity_relationship_id",
    compute_uuid_udf(struct(*[col(c) for c in transformed_relationship_columns]))
)
# transformed_relationship = transformed_relationship.withColumn(
#     "business_entity_relationship_id",
#     compute_uuid_udf(struct(*transformed_relationship.columns))
# )


# Show distinct rows in the resulting DataFrame
transformed_relationship.distinct().show(truncate=False)



above code which i have shared is for data team

see now compute_uuid function used by api team and data team

same function being used

business_entity_relationship_id generated by data team is "592283ce-db54-7b02-fce5-926821f6606e" for same values

but for api is 48d38643-c4cd-4f30-4a7b-e4233541127 for same values

business_entity_relationship_id	stg_business_entity_id	business_entity_contact_id	stg_related_business_entity_id	related_business_entity_contact_id	business_entity_role	related_business_entity_role	is_active	created_by	created_date
592283ce-db54-7b02-fce5-926821f6606e	6af7db6f-50e6-23bd-f58a-f8a917ad0e71	NULL	b3a419c5-8b74-8d05-7e61-dcb1ce6ead33	NULL	Supplier	Client	TRUE	PFD	7/8/2025 0:00
48d38643-c4cd-4f30-4a7b-e42335411279	6af7db6f-50e6-23bd-f58a-f8a917ad0e71	NULL	b3a419c5-8b74-8d05-7e61-dcb1ce6ead33	NULL	Supplier	Client	TRUE	data_admin	44:22.4
48d38643-c4cd-4f30-4a7b-e42335411279	6af7db6f-50e6-23bd-f58a-f8a917ad0e71	NULL	b3a419c5-8b74-8d05-7e61-dcb1ce6ead33	NULL	Supplier	Client	TRUE	data_admin	18:12.7


y these descrepencies. how it can it be fixed in data end
